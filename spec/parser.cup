import java_cup.runtime.*;
import compiler.core.*;
import compiler.analysis.*;
import compiler.generator.*;
import compiler.util.*;
import java.util.ArrayList;
import compiler.generated.*;

parser code  {:

 public void report_error(String message, Object info){
   StringBuffer m = new StringBuffer("Error ");

   if (info instanceof compiler.core.JavaSymbol) {
      compiler.core.JavaSymbol s = ((compiler.core.JavaSymbol) info);

      if (s.getLine() >= 0) {
          m.append(" in line "+(s.getLine()));
          if (s.getColumn() >= 0)
              m.append(", column "+(s.getColumn()));
      }
   }

   m.append(" : "+message);

   System.out.print(m);
 }

 public void report_fatal_error(String message, Object info) {
   report_error(message, info);
   throw new RuntimeException("Fatal Syntax Error");
 }
:};

terminal	IDENTIFIER, I_CONSTANT, F_CONSTANT, STRING_LITERAL, FUNC_NAME, SIZEOF;
terminal	PTR_OP, INC_OP, DEC_OP, LEFT_OP, RIGHT_OP, LE_OP, GE_OP, EQ_OP, NE_OP;
terminal	AND_OP, OR_OP, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN;
terminal	SUB_ASSIGN, LEFT_ASSIGN, RIGHT_ASSIGN, AND_ASSIGN;
terminal	XOR_ASSIGN, OR_ASSIGN;
terminal	TYPEDEF_NAME, ENUMERATION_CONSTANT;

terminal	TYPEDEF, EXTERN, STATIC, AUTO, REGISTER, INLINE;
terminal	CONST, RESTRICT, VOLATILE;
terminal	BOOL, CHAR, SHORT, INT, LONG, SIGNED, UNSIGNED, FLOAT, DOUBLE, VOID;
terminal	COMPLEX, IMAGINARY;
terminal	STRUCT, UNION, ENUM, ELLIPSIS;

terminal LT, GT, AND, PIPE, DOT, DDOT, TIL, CARET, EQUALS, INTER, LPAREN, RPAREN, COMMA, PLUS, MINUS, LBRA, RBRA, LKEY, RKEY, SEMICOLON, STAR, BAR, PERC, EXCLA;

terminal	CASE, DEFAULT, IF, ELSE, SWITCH, WHILE, DO, FOR, GOTO, CONTINUE, BREAK, RETURN;

terminal	ALIGNAS, ALIGNOF, ATOMIC, GENERIC, NORETURN, STATIC_ASSERT, THREAD_LOCAL;

// Nonterminals
non terminal translation_unit, external_declaration, function_definition, declaration_list, primary_expression;
non terminal constant, enumeration_constant, string, generic_selection, generic_assoc_list, generic_association;
non terminal postfix_expression, argument_expression_list, unary_expression, unary_operator, cast_expression;
non terminal multiplicative_expression, additive_expression, shift_expression, relational_expression;
non terminal equality_expression, and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal logical_and_expression, logical_or_expression, conditional_expression, assignment_expression;
non terminal assignment_operator, expression, constant_expression, declaration, declaration_specifiers;
non terminal init_declarator_list, init_declarator, storage_class_specifier, type_specifier, struct_or_union_specifier;
non terminal struct_or_union, struct_declaration_list, struct_declaration, specifier_qualifier_list, struct_declarator_list;
non terminal struct_declarator, enum_specifier, enumerator_list, enumerator, atomic_type_specifier, type_qualifier;
non terminal function_specifier, alignment_specifier, declarator, direct_declarator, pointer, type_qualifier_list;
non terminal parameter_type_list, parameter_type_list_opt, parameter_list, parameter_declaration, identifier_list, type_name, abstract_declarator;
non terminal direct_abstract_declarator, initializer, initializer_list, designation, designator_list, designator;
non terminal static_assert_declaration, statement, labeled_statement, compound_statement, block_item_list;
non terminal block_item, expression_statement, selection_statement, iteration_statement, jump_statement;

precedence nonassoc ELSE;
precedence nonassoc ATOMIC;

start with translation_unit;


translation_unit	::= external_declaration				{:	Logger.print("translation_unit ::= external_declaration");	:}
					| translation_unit external_declaration	{:	Logger.print("translation_unit ::= translation_unit external_declaration");	:};


external_declaration	::= function_definition	{:	Logger.print("external_declaration ::= function_definition");	:}
						| declaration			{:	Logger.print("external_declaration ::= declaration");	:};


function_definition	::= declaration_specifiers declarator declaration_list compound_statement			{:	Logger.print("function_definition ::= declaration_specifiers declarator declaration_list compound_statement");	:}
					| declaration_specifiers:t IDENTIFIER:id LPAREN parameter_type_list_opt:pl RPAREN	{:	Logger.print("function_definition ::=  declaration_specifiers IDENTIFIER LPAREN parameter_type_list_opt RPAREN <begin>"+id+pl+t);
                                                      SemanticImpl.getInstance().validateFunction((String) id,(ArrayList<Parameter>) pl,(Type)t);
																											/*codeEngine.functionDeclarationBegin((String) id, (ArrayList<Parameter>) pl, (Type) t);*/
																											:}
					compound_statement:st																{:	if (st instanceof Expression) {
																												SemanticImpl.getInstance().exitCurrentScope((Expression) st);
																											} else {
																												SemanticImpl.getInstance().exitCurrentScope();
																											}
																											/*codeEngine.functionDeclarationEnd();*/
																											Logger.print("function_definition ::=	declaration_specifiers IDENTIFIER LPAREN parameter_type_list_opt RPAREN <end>");	:};

parameter_type_list_opt ::=							{:	Logger.print("parameter_type_list_opt ::=	<empty>");	:}
						| parameter_type_list:pl	{:	RESULT = pl;
														Logger.print("parameter_type_list_opt ::=	parameter_type_list");	:};


declaration	::= declaration_specifiers:t SEMICOLON						{:	SemanticImpl.getInstance().addVariablesFromTempList((Type) t);
																			Logger.print("declaration ::=	declaration_specifiers SEMICOLON");	:}
			| declaration_specifiers:t init_declarator_list:v SEMICOLON	{:	SemanticImpl.getInstance().addVariablesFromTempList((Type) t);
																			Logger.print("declaration ::=	declaration_specifiers init_declarator_list SEMICOLON");	:}
			| static_assert_declaration									{:	Logger.print("declaration ::=	static_assert_declaration");	:};


declaration_specifiers	::= storage_class_specifier declaration_specifiers:t	{:	RESULT = t;
																					Logger.print("declaration_specifiers ::=	storage_class_specifier declaration_specifiers");	:}
						| storage_class_specifier								{:	Logger.print("declaration_specifiers ::=	storage_class_specifier");	:}
						| type_specifier:t declaration_specifiers				{:	RESULT = t;
																					Logger.print("declaration_specifiers ::=	type_specifier declaration_specifiers");	:}
						| type_specifier:t										{:	RESULT = t;
																					Logger.print("declaration_specifiers ::=	type_specifier");	:}
						| type_qualifier declaration_specifiers:t				{:	RESULT = t;
																					Logger.print("declaration_specifiers ::=	type_qualifier declaration_specifiers");	:}
						| type_qualifier										{:	Logger.print("declaration_specifiers ::=	type_qualifier");	:}
						| function_specifier declaration_specifiers				{:	Logger.print("declaration_specifiers ::=	function_specifier declaration_specifiers");	:}
						| function_specifier									{:	Logger.print("declaration_specifiers ::=	function_specifier");	:}
						| alignment_specifier declaration_specifiers			{:	Logger.print("declaration_specifiers ::=	alignment_specifier declaration_specifiers");	:}
						| alignment_specifier									{:	Logger.print("declaration_specifiers ::=	alignment_specifier");	:};


declarator	::= pointer direct_declarator	{:	Logger.print("declarator ::=	pointer direct_declarator");	:}
			| direct_declarator:v 			{:	RESULT = v;
												Logger.print("declarator ::=	direct_declarator");	:};


declaration_list	::= declaration					{:	Logger.print("declaration_list ::=	declaration");	:}
					| declaration_list declaration	{:	Logger.print("declaration_list ::=	declaration_list declaration");	:};


compound_statement	::= LKEY RKEY					{:	Logger.print("compound_statement ::=	LKEY RKEY");	:}
					| LKEY block_item_list:st RKEY	{: 	RESULT = st;
															Logger.print("compound_statement ::=	LKEY block_item_list RKEY");	:};



init_declarator_list	::= init_declarator:v 							{:	RESULT = v;
																			Logger.print("init_declarator_list ::=	init_declarator");	:}
						| init_declarator_list COMMA init_declarator:v	{:	RESULT = v;
																			Logger.print("init_declarator_list ::=	init_declarator_list COMMA init_declarator");	:};


type_specifier	::= VOID					{:	RESULT = new Type("void");	:}
				| CHAR						{:	RESULT = new Type("char");	:}
				| SHORT						{:	RESULT = new Type("short");	:}
				| INT:i						{:	RESULT = new Type("int");	:}
				| LONG						{:	RESULT = new Type("long");	:}
				| FLOAT						{:	RESULT = new Type("float");	:}
				| DOUBLE					{:	RESULT = new Type("double");	:}
				| SIGNED					{:	RESULT = new Type("signed");	:}
				| UNSIGNED					{:	RESULT = new Type("unsigned");	:}
				| BOOL						{:	RESULT = new Type("bool");	:}
				| COMPLEX
				| IMAGINARY
				| atomic_type_specifier
				| struct_or_union_specifier
				| enum_specifier
				| TYPEDEF_NAME;


direct_declarator	::= IDENTIFIER:id																		{:	RESULT = id;	:}
					| LPAREN declarator RPAREN
					| direct_declarator LBRA RBRA
					| direct_declarator LBRA STAR RBRA
					| direct_declarator LBRA STATIC type_qualifier_list assignment_expression RBRA
					| direct_declarator LBRA STATIC assignment_expression RBRA
					| direct_declarator LBRA type_qualifier_list STAR RBRA
					| direct_declarator LBRA type_qualifier_list STATIC assignment_expression RBRA
					| direct_declarator LBRA type_qualifier_list assignment_expression RBRA
					| direct_declarator LBRA type_qualifier_list RBRA
					| direct_declarator LBRA assignment_expression RBRA
					| direct_declarator:id LPAREN parameter_type_list:parameter_list RPAREN
					| direct_declarator LPAREN RPAREN
					| direct_declarator LPAREN identifier_list RPAREN;


block_item_list	::= block_item:st				{:	RESULT = st;	:}
				| block_item_list block_item:st	{:	RESULT = st;	:};


init_declarator	::= declarator:id EQUALS initializer:ep	{:	Variable v = new Variable((String) id, new Type("null"), (Expression) ep);
															SemanticImpl.getInstance().addVariableToTempList(v);
															/*codeEngine.generateAttribution((String) id, ep);*/
															RESULT = v;	:}
				| declarator:id							{:	Variable v = new Variable((String) id, new Type("null"));
															SemanticImpl.getInstance().addVariableToTempList(v);
															RESULT = v;	:};


constant_expression	::= conditional_expression;


assignment_expression	::= conditional_expression:e	{:	Logger.print("assignment_expression ::=	conditional_expression");
																									RESULT=e;	:}
						| unary_expression:id assignment_operator:op assignment_expression:e	{:	Logger.print("assignment_expression ::=	unary_expression assignment_operator assignment_expression"+id+op+e);
																									Variable var;
																									if (id instanceof String) {
                                                    													SemanticImpl.getInstance().checkVariableAttribution((String) id, (Expression) e);
																										var = SemanticImpl.getInstance().findVariableByIdentifier((String) id);
																										var.setValue((Expression) e);
																										RESULT = e;
																									} else {
																										RESULT = e;
                                                    												}
																									/*codeEngine.generateAttribution((String) id, (Operation) op, (Expression) e);*/	:};


parameter_type_list	::= parameter_list COMMA ELLIPSIS
					| parameter_list:pl					{:	RESULT = pl;	Logger.print("parameter_type_list	::= parameter_list"); :};


block_item	::= declaration
			| statement:st	{:	RESULT = st;	:};


initializer	::= LKEY initializer_list RKEY
			| LKEY initializer_list COMMA RKEY
			| assignment_expression:ep				{:	RESULT=ep;	:};


conditional_expression	::= logical_or_expression:ep												{:	RESULT = ep;	:}
						| logical_or_expression INTER expression DDOT conditional_expression;


unary_expression	::= postfix_expression:ep				{:	RESULT = ep; :}
					| INC_OP unary_expression
					| DEC_OP unary_expression
					| unary_operator:op cast_expression:re	{:	/*SemanticImpl.getInstance().validateUnaryOperatorExpressionType((Expression) re);*/
																RESULT = SemanticImpl.getInstance().getExpression((Expression) re, op.toString(), (Expression) re);
																/*codeEngine.operation((Expression) RESULT, (Expression) re, (Operation) op, (Expression) re);*/	:}
					| SIZEOF unary_expression
					| SIZEOF LPAREN type_name RPAREN
					| ALIGNOF LPAREN type_name RPAREN;


assignment_operator	::= EQUALS 		{:	RESULT = "==";	:}
					| MUL_ASSIGN 	{:	RESULT = "*=";	:}
					| DIV_ASSIGN	{:	RESULT = "/=";	:}
					| MOD_ASSIGN	{:	RESULT = "%=";	:}
					| ADD_ASSIGN	{:	RESULT = "+=";	:}
					| SUB_ASSIGN	{:	RESULT = "-=";	:}
					| LEFT_ASSIGN	{:	RESULT = ">>=";	:}
					| RIGHT_ASSIGN	{:	RESULT = "<<=";	:}
					| AND_ASSIGN	{:	RESULT = "&=";	:}
					| XOR_ASSIGN	{:	RESULT = "^=";	:}
					| OR_ASSIGN		{:	RESULT = "|=";	:};


parameter_list	::= parameter_declaration:p							{:	Logger.print("parameter_list	::= parameter_declaration"+p); RESULT = ListCreator.newList(p);	:}
				| parameter_list:pl COMMA parameter_declaration:p	{:	((ArrayList<Parameter>) pl).add(0, (Parameter) p);
																		RESULT = pl;	:};


statement	::= labeled_statement
			| compound_statement
			| expression_statement
			| selection_statement
			| iteration_statement
			| jump_statement:st		{:	RESULT = st;	:};


initializer_list	::= designation initializer
					| initializer
					| initializer_list COMMA designation initializer
					| initializer_list COMMA initializer;


logical_or_expression	::= logical_and_expression:ep {: RESULT = ep; :}
						| logical_or_expression:le OR_OP logical_and_expression:re;


expression	::= assignment_expression:ep {: RESULT=ep; :}
			| expression COMMA assignment_expression;


postfix_expression	::= primary_expression:ep	{:	RESULT = ep;	:}
					| postfix_expression LBRA expression RBRA
					| postfix_expression:id LPAREN RPAREN	{: SemanticImpl.getInstance().verifyCall((String)id,(ArrayList<Expression>) new ArrayList());
																							RESULT = id;	:}
					| postfix_expression:id LPAREN argument_expression_list:args RPAREN	{: if(args != null){ Logger.print("Line 164"); SemanticImpl.getInstance().verifyCall((String)id,(ArrayList<Expression>) args); RESULT = id;
        								}else{ Logger.print("Line 164b"); SemanticImpl.getInstance().verifyCall((String)id,new ArrayList<Expression>()); RESULT= id;}
        								/*SemanticImpl.getInstance().getCodeGenerator().generateCallFunction(id);*/:}
					| postfix_expression DOT IDENTIFIER
					| postfix_expression PTR_OP IDENTIFIER
					| postfix_expression INC_OP
					| postfix_expression DEC_OP
					| LPAREN type_name RPAREN LKEY initializer_list RKEY
					| LPAREN type_name RPAREN LKEY initializer_list COMMA RKEY;


unary_operator	::= AND
				| STAR
				| PLUS
				| MINUS
				| TIL
				| EXCLA			{:	RESULT = "!";	:};


cast_expression	::= unary_expression:ep 						{:	if (ep instanceof String) {
																		Variable v = SemanticImpl.getInstance().findVariableByIdentifier((String) ep);
																		if (v.getValue() != null) {
																			RESULT = v.getValue();
																		} else {
																			RESULT = new Expression((Type) v.getType(), (String) ep); //It's a parameter
																		}
																	} else {
																		RESULT = ep;
																	}	:}
				| LPAREN type_name RPAREN cast_expression:ep	{:	RESULT = ep;	:};


parameter_declaration	::= declaration_specifiers:t declarator:id		{:	Variable v = new Variable((String) id, (Type) t);
																			RESULT = v;	Logger.print("parameter_declaration	::= declaration_specifiers declarator"); :}
						| declaration_specifiers:t abstract_declarator:id {: RESULT = new Variable((String) id, (Type) t); Logger.print("parameter_declaration	::= declaration_specifiers abstract_declarator"); :}
						| declaration_specifiers:d {: RESULT = d; Logger.print("parameter_declaration	::= declaration_specifiers"+d); :}
            ;


labeled_statement	::= IDENTIFIER DDOT statement
					| CASE constant_expression DDOT statement
					| DEFAULT DDOT statement;


expression_statement	::= SEMICOLON
						| expression SEMICOLON;


selection_statement	::= IF LPAREN expression RPAREN statement ELSE statement
					| IF LPAREN expression RPAREN statement
					| SWITCH LPAREN expression RPAREN statement ;


jump_statement	::= GOTO IDENTIFIER SEMICOLON
				| CONTINUE SEMICOLON
				| BREAK SEMICOLON
				| RETURN SEMICOLON
				| RETURN expression:ep SEMICOLON	{:	Logger.print("jump_statement ::= RETURN expression SEMICOLON");
														((Expression) ep).setReturn(true);
														/*codeEngine.returnExpression((Expression) ep);*/
														RESULT=ep;	:};


logical_and_expression	::= inclusive_or_expression:ie {: RESULT = ie; :}
						| logical_and_expression:le AND_OP inclusive_or_expression;


primary_expression	::= IDENTIFIER:id				{:	Logger.print("primary_expression ::= IDENTIFIER");
														RESULT = id;	:}
					| constant:c					{:	Logger.print("primary_expression ::= constant");
														RESULT = c;	:}
					| string:s						{:	Logger.print("primary_expression ::= string");
														RESULT = s;	:}
					| LPAREN expression:ep RPAREN	{:	Logger.print("primary_expression ::= LPAREN expression RPAREN");
														RESULT = ep;	:}
					| generic_selection;


argument_expression_list	::= assignment_expression:ep									{:	Logger.print("argument_expression_list ::= assignment_expression");
																								/*ExpressionList el = new ExpressionList((Expression) ep);*/
																								/*RESULT = el;*/	:}
							| argument_expression_list:epl COMMA assignment_expression:ep	{:	Logger.print("argument_expression_list ::= argument_expression_list COMMA assignment_expression");
																								/*((ExpressionList) epl).add((Expression)ep);*/
																								/*RESULT = epl;	*/:};


inclusive_or_expression	::= exclusive_or_expression:ep							{:	Logger.print("inclusive_or_expression ::= exclusive_or_expression");
																					RESULT = ep;	:}
						| inclusive_or_expression PIPE exclusive_or_expression;


constant	::= I_CONSTANT:c		{:	Logger.print("constant ::= I_CONSTANT");
										RESULT = new Expression(new Type("int"), c.toString());	:}
			| F_CONSTANT:c			{:	Logger.print("constant ::= F_CONSTANT");
										RESULT = new Expression(new Type("float"), c.toString());	:}
			| ENUMERATION_CONSTANT;


string	::= STRING_LITERAL:s	{:	Logger.print("string ::= STRING_LITERAL");
									Expression ep = new Expression(new Type("char"),(String) s);
									RESULT = ep;	:}
		| FUNC_NAME;


exclusive_or_expression	::= and_expression:ep							{:	Logger.print("exclusive_or_expression ::= and_expression");
																			RESULT = ep;	:}
						| exclusive_or_expression CARET and_expression;


and_expression	::= equality_expression:ep					{:	Logger.print("and_expression ::= equality_expression");
																RESULT = ep;	:}
				| and_expression AND equality_expression;


equality_expression	::= relational_expression:ep						{:	Logger.print("equality_expression ::= relational_expression");
																			RESULT = ep;	:}
					| equality_expression EQ_OP relational_expression
					| equality_expression NE_OP relational_expression;


relational_expression	::= shift_expression:ep							{:	Logger.print("relational_expression ::= shift_expression");
																			RESULT = ep;	:}
						| relational_expression LT shift_expression
						| relational_expression GT shift_expression
						| relational_expression LE_OP shift_expression
						| relational_expression GE_OP shift_expression;


shift_expression	::= additive_expression:ep							{:	Logger.print("shift_expression ::= additive_expression");
																			RESULT = ep;	:}
					| shift_expression LEFT_OP additive_expression
					| shift_expression RIGHT_OP additive_expression;


additive_expression	::= multiplicative_expression:ep							{:	Logger.print("additive_expression ::= multiplicative_expression");
																					RESULT = ep;	:}
					| additive_expression:le PLUS multiplicative_expression:re	{:	Logger.print("additive_expression ::= additive_expression PLUS multiplicative_expression");
																					RESULT = SemanticImpl.getInstance().getExpression((Expression) le, "+", (Expression) re);
																					/*codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("PLUS"), (Expression) re);*/	:}
					| additive_expression:le MINUS multiplicative_expression:re	{:	Logger.print("additive_expression ::= additive_expression MINUS multiplicative_expression");
																					RESULT = SemanticImpl.getInstance().getExpression((Expression) le, "-", (Expression) re);
																					/*codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("MINUS"), (Expression) re);	*/:};


multiplicative_expression	::= cast_expression:ep									{:	Logger.print("multiplicative_expression ::= cast_expression");
																						RESULT = ep;	:}
							| multiplicative_expression:le STAR cast_expression:re	{:	Logger.print("multiplicative_expression ::= multiplicative_expression STAR cast_expression");
																						RESULT = SemanticImpl.getInstance().getExpression((Expression) le, "*", (Expression) re);
																						/*codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("MULT"), (Expression) re);*/	:}
							| multiplicative_expression:le BAR cast_expression:re	{:	Logger.print("multiplicative_expression ::= multiplicative_expression BAR cast_expression");
																						RESULT = SemanticImpl.getInstance().getExpression((Expression) le, "/", (Expression) re);
																						/*codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("BAR"), (Expression) re);*/	:}
							| multiplicative_expression:le PERC cast_expression:re	{:	Logger.print("multiplicative_expression ::= multiplicative_expression PERC cast_expression");
																						RESULT = SemanticImpl.getInstance().getExpression((Expression) le, "%", (Expression) re);
																						/*codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("PERC"), (Expression) re);*/	:};



designation	::= designator_list EQUALS;


designator_list	::= designator
				| designator_list designator;


designator	::= LBRA constant_expression RBRA
			| DOT IDENTIFIER;


storage_class_specifier ::= TYPEDEF
						| EXTERN
						| STATIC
						| THREAD_LOCAL
						| AUTO
						| REGISTER;


type_qualifier	::= CONST
				| RESTRICT
				| VOLATILE
				| ATOMIC;


function_specifier	::= INLINE
					| NORETURN;


pointer	::= STAR type_qualifier_list pointer
		| STAR type_qualifier_list
		| STAR pointer
		| STAR;


struct_or_union_specifier	::= struct_or_union LKEY struct_declaration_list RKEY
							| struct_or_union IDENTIFIER LKEY struct_declaration_list RKEY
							| struct_or_union IDENTIFIER;


enum_specifier	::= ENUM LKEY enumerator_list RKEY
				| ENUM LKEY enumerator_list COMMA RKEY
				| ENUM IDENTIFIER LKEY enumerator_list RKEY
				| ENUM IDENTIFIER LKEY enumerator_list COMMA RKEY
				| ENUM IDENTIFIER;


type_qualifier_list	::= type_qualifier
					| type_qualifier_list type_qualifier;


type_name	::= specifier_qualifier_list abstract_declarator
			| specifier_qualifier_list;


identifier_list	::= IDENTIFIER
				| identifier_list COMMA IDENTIFIER;


struct_or_union ::= STRUCT
				| UNION;


struct_declaration_list	::= struct_declaration
						| struct_declaration_list struct_declaration;


enumerator_list	::= enumerator
				| enumerator_list COMMA enumerator;


specifier_qualifier_list	::= type_specifier specifier_qualifier_list
							| type_specifier
							| type_qualifier specifier_qualifier_list
							| type_qualifier;


abstract_declarator	::= pointer direct_abstract_declarator
					| pointer
					| direct_abstract_declarator;


struct_declaration	::= specifier_qualifier_list SEMICOLON
					| specifier_qualifier_list struct_declarator_list SEMICOLON
					| static_assert_declaration;


enumerator	::= enumeration_constant EQUALS constant_expression
			| enumeration_constant;


direct_abstract_declarator	::= LPAREN abstract_declarator RPAREN
							| LBRA RBRA
							| LBRA STAR RBRA
							| LBRA STATIC type_qualifier_list assignment_expression RBRA
							| LBRA STATIC assignment_expression RBRA
							| LBRA type_qualifier_list STATIC assignment_expression RBRA
							| LBRA type_qualifier_list assignment_expression RBRA
							| LBRA type_qualifier_list RBRA
							| LBRA assignment_expression RBRA
							| direct_abstract_declarator LBRA RBRA
							| direct_abstract_declarator LBRA STAR RBRA
							| direct_abstract_declarator LBRA STATIC type_qualifier_list assignment_expression RBRA
							| direct_abstract_declarator LBRA STATIC assignment_expression RBRA
							| direct_abstract_declarator LBRA type_qualifier_list assignment_expression RBRA
							| direct_abstract_declarator LBRA type_qualifier_list STATIC assignment_expression RBRA
							| direct_abstract_declarator LBRA type_qualifier_list RBRA
							| direct_abstract_declarator LBRA assignment_expression RBRA
							| LPAREN RPAREN
							| LPAREN parameter_type_list RPAREN
							| direct_abstract_declarator LPAREN RPAREN
							| direct_abstract_declarator LPAREN parameter_type_list RPAREN;


iteration_statement	::= WHILE LPAREN expression RPAREN statement
					| DO statement WHILE LPAREN expression RPAREN SEMICOLON
					| FOR LPAREN expression_statement expression_statement RPAREN statement
					| FOR LPAREN expression_statement expression_statement expression RPAREN statement
					| FOR LPAREN declaration expression_statement RPAREN statement
					| FOR LPAREN declaration expression_statement expression RPAREN statement;


struct_declarator_list	::= struct_declarator
						| struct_declarator_list COMMA struct_declarator;


enumeration_constant	::= IDENTIFIER;


struct_declarator	::= DDOT constant_expression
					| declarator DDOT constant_expression
					| declarator;



static_assert_declaration	::= STATIC_ASSERT LPAREN constant_expression COMMA STRING_LITERAL RPAREN SEMICOLON;


alignment_specifier	::= ALIGNAS LPAREN type_name RPAREN
					| ALIGNAS LPAREN constant_expression RPAREN;


atomic_type_specifier	::= ATOMIC LPAREN type_name RPAREN;


generic_selection	::= GENERIC LPAREN assignment_expression COMMA generic_assoc_list RPAREN;


generic_assoc_list	::= generic_association
					| generic_assoc_list COMMA generic_association;


generic_association	::= type_name DDOT assignment_expression
					| DEFAULT DDOT assignment_expression;
