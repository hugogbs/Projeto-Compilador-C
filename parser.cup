import java_cup.runtime.*;
import java.util.*;
import java.io.*;

parser code {:

    // Connect this parser to a scanner!
    scanner s;
    Parser(scanner s){ this.s=s; }

    public void report_error(String message, Object info)  {
        System.out.println("Warning - " + message);
    }

    public void report_fatal_error(String message, Object info)  {
        System.out.println("Error - " + message);
        System.exit(-1);
    }

:}

/* define how to connect to the scanner! */
init with {: s.init(); :};
scan with {: return s.next_token(); :};

/* Preliminaries to set up and use the scanner.  */
/*init with {: scanner.init();              :};
scan with {: return scanner.next_token(); :};*/

/* Terminals (tokens returned by the scanner). */
terminal    LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, COMMA, SEMI;
terminal    ADD, SUB, STAR, DIV, NOT, AND, OR, EQ, NE, LE, LT, GE, GT, ASSIGN;
terminal    AUTO, DOUBLE, INT, STRUCT, CONST, SHORT, UNSIGN, BREAK, ELSE, LONG, SWITCH, CONTINUE, FOR, SIGNED, VOID, CASE,
            ENUM, REGISTER, TYPEDEF, DEFAULT, GOTO, SIZEOF, VOLATILE, CHAR, EXTERN, RETURN, UNION, DO, IF, STATIC, WHILE;
terminal    IDENTIFIER, INT_LITERAL, STRINGLITERAL, CHARLITERAL;

/* Non terminals */
/*non terminal            expr_list, expr_part;
non terminal Integer    expr, term, factor;*/

/* Precedences */
/*precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence left UMINUS; */

/* The grammar */
/* Estão sendo usados alguns tokens aqui
que ainda não estão no analisador lexico
no entanto eles ainda precisam ser definidos.
Usei os mesmos nomes que estão nesse link:
https://www.lysator.liu.se/c/ANSI-C-grammar-l.html#INC-OP*/
start with compilation_unit;


primary_expression ::=
  	IDENTIFIER
  	| CONSTANT
  	| STRING_LITERAL
  	| LPAREN expression RPAREN;

postfix_expression
	primary_expression
	| postfix_expression LBRACKET expression RBRACKET
	| postfix_expression LBRACKET RBRACKET
	| postfix_expression LBRACKET argument_expression_list RBRACKET
	| postfix_expression POINT IDENTIFIER
	| postfix_expression PTR_OP IDENTIFIER
	| postfix_expression INC_OP
	| postfix_expression DEC_OP;

argument_expression_list
	: assignment_expression
	| argument_expression_list COMMA assignment_expression;

unary_expression ::=
	postfix_expression
	| INC_OP unary_expression
	| DEC_OP unary_expression
	| unary_operator cast_expression
	| SIZEOF unary_expression
	| SIZEOF LPAREN type_name RPAREN;


// Povavelmente isso precisa ser definido no lexer e não aqui
unary_operator ::=
  	'&'
    | '*'
  	| '+'
  	| '-'
  	| '~'
  	| '!';

cast_expression ::=
    unary_expression
    | LPAREN type_name RPAREN cast_expression;

multiplicative_expression :==
  	cast_expression
  	| multiplicative_expression STAR cast_expression
  	| multiplicative_expression  DIV cast_expression
  	| multiplicative_expression MOD cast_expression;

additive_expression ::=
  	multiplicative_expression
  	| additive_expression ADD multiplicative_expression
  	| additive_expression SUB multiplicative_expression;

shift_expression ::=
  	additive_expression
  	| shift_expression LEFT_OP additive_expression
  	| shift_expression RIGHT_OP additive_expression;

relational_expression ::=
  	shift_expression
  	| relational_expression LT shift_expression
  	| relational_expression GT shift_expression
  	| relational_expression LE shift_expression
  	| relational_expression GE shift_expression;

equality_expression ::=
  	relational_expression
  	| equality_expression EQ relational_expression
  	| equality_expression NE relational_expression;

and_expression ::=
  	equality_expression
  	| and_expression BIT_AND equality_expression;

exclusive_or_expression ::=
  	and_expression
  	| exclusive_or_expression XOR and_expression;

inclusive_or_expression ::=
  	exclusive_or_expression
  	| inclusive_or_expression BIT_OR exclusive_or_expression;

logical_and_expression ::=
  	inclusive_or_expression
  	| logical_and_expression AND inclusive_or_expression;

logical_or_expression ::=
  	logical_and_expression
  	| logical_or_expression OR logical_and_expression;

conditional_expression ::=
  	logical_or_expression
  	| logical_or_expression QUESTION expression COLON conditional_expression;

    assignment_expression
    	: conditional_expression
    	| unary_expression assignment_operator assignment_expression
    	;

assignment_operator ::=
  	ASSIGN
  	| MUL_ASSIGN
  	| DIV_ASSIGN
  	| MOD_ASSIGN
  	| ADD_ASSIGN
  	| SUB_ASSIGN
  	| LEFT_ASSIGN
  	| RIGHT_ASSIGN
  	| AND_ASSIGN
  	| XOR_ASSIGN
  	| OR_ASSIGN;

expression ::=
  	assignment_expression
  	| expression COMMA assignment_expression;

constant_expression ::=
	 conditional_expression;


compilation_unit ::=
    external_declaration |
    compilation_unit external_declaration;

external_declaration ::=
    function_definition |
    declaration;

function_definition ::=
    declaration_specifiers declarator declaration_list compound_statement |
    declaration_specifiers declarator compound_statement |
    declarator declaration_list compound_statement |
    declarator compound_statement;

declaration ::=
    declaration_specifiers SEMI |
    declaration_specifiers init_declaration_list SEMI;

declaration_specifiers ::=
    storage_class_specifier |
    storage_class_specifier declaration_specifiers |
    type_specifier |
    type_specifier declaration_specifiers |
    type_qualifier |
    type_qualifier declaration_specifiers;

init_declarator_list ::=
  	init_declarator
  	| init_declarator_list COMMA init_declarator;

init_declarator ::=
  	declarator
  	| declarator ASSIGN initializer;

storage_class_specifier
  	: TYPEDEF
  	| EXTERN
  	| STATIC
  	| AUTO
  	| REGISTER;


type_specifier ::=
  	 VOID
  	| CHAR
  	| SHORT
  	| INT
  	| LONG
  	| FLOAT
  	| DOUBLE
  	| SIGNED
  	| UNSIGNED
  	| struct_or_union_specifier
  	| enum_specifier
  	| TYPE_NAME;

struct_or_union_specifier ::=
    struct_or_union IDENTIFIER LBRACE struct_declaration_list RBRACE
    | struct_or_union LBRACE struct_declaration_list RBRACE
    | struct_or_union IDENTIFIER;

struct_or_union
  	: STRUCT
  	| UNION;


struct_declaration_list ::=
  	struct_declaration
  	| struct_declaration_list struct_declaration;

  struct_declaration ::=
  	specifier_qualifier_list struct_declarator_list SEMI;

specifier_qualifier_list ::=
  	type_specifier specifier_qualifier_list
  	| type_specifier
  	| type_qualifier specifier_qualifier_list
  	| type_qualifier;

struct_declarator_list ::=
  	: struct_declarator
  	| struct_declarator_list COMMA struct_declarator;

struct_declarator ::=
  	declarator
  	| COLON constant_expression
  	| declarator COLON constant_expression;

enum_specifier ::=
  	ENUM LBRACE enumerator_list RBRACE
  	| ENUM IDENTIFIER LBRACE enumerator_list RBRACE
  	| ENUM IDENTIFIER;

enumerator_list ::=
  	enumerator
  	| enumerator_list COMMA enumerator;

enumerator ::=
  	IDENTIFIER
  	| IDENTIFIER ASSIGN constant_expression;

type_qualifier ::=
  	CONST
  	| VOLATILE
  	;

declarator ::=
  	pointer direct_declarator
  	| direct_declarator;

direct_declarator ::=
  	IDENTIFIER
  	| LPAREN declarator RPAREN
  	| direct_declarator LBRACKET constant_expression RBRACKET
  	| direct_declarator LBRACKET RBRACKET
  	| direct_declarator LPAREN parameter_type_list RPAREN
  	| direct_declarator LPAREN identifier_list RPAREN
  	| direct_declarator LPAREN RPAREN;

pointer
  	: STAR
  	| STAR type_qualifier_list
  	| STAR pointer
  	| STAR type_qualifier_list pointer;

type_qualifier_list ::=
  	type_qualifier
  	| type_qualifier_list type_qualifier;


parameter_type_list ::=
  	: parameter_list
  	| parameter_list COMMA ELLIPSIS;

parameter_list
  	parameter_declaration
  	| parameter_list COMMA parameter_declaration;

parameter_declaration ::=
  	declaration_specifiers declarator
  	| declaration_specifiers abstract_declarator
  	| declaration_specifiers;

identifier_list ::=
  	IDENTIFIER
  	| identifier_list COMMA IDENTIFIER;

type_name ::=
  	specifier_qualifier_list
  	| specifier_qualifier_list abstract_declarator;

abstract_declarator ::=
  	pointer
  	| direct_abstract_declarator
  	| pointer direct_abstract_declarator;

direct_abstract_declarator ::=
  	LPAREN abstract_declarator RPAREN
  	| LBRACKET RBRACKET
  	| LBRACKET constant_expression RBRACKET
  	| direct_abstract_declarator LBRACKET RBRACKET
  	| direct_abstract_declarator LBRACKET constant_expression RBRACKET
  	| LPAREN RPAREN
  	| LPAREN parameter_type_list RPAREN
  	| direct_abstract_declarator LPAREN RPAREN
  	| direct_abstract_declarator LPAREN parameter_type_list RPAREN;

initializer ::=
  	assignment_expression
  	| LBRACE initializer_list RBRACE
  	| LBRACE initializer_list COMMA RBRACE;

initializer_list ::=
  	initializer
  	| initializer_list COMMA initializer;
