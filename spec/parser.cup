import java_cup.runtime.*;
import compiler.core.*;
import compiler.analysis.*;
import compiler.generator.*;
import compiler.util.*;
import java.util.ArrayList;

parser code  {:
 public void report_error(String message, Object info){
   StringBuffer m = new StringBuffer("Error ");

   if (info instanceof compiler.core.JavaSymbol) {
      compiler.core.JavaSymbol s = ((compiler.core.JavaSymbol) info);

      if (s.getLine() >= 0) {
          m.append(" in line "+(s.getLine()));
          if (s.getColumn() >= 0)
              m.append(", column "+(s.getColumn()));
      }
   }

   m.append(" : "+message);

   System.out.println(m);
 }

 public void report_fatal_error(String message, Object info) {
   report_error(message, info);
   throw new RuntimeException("Fatal Syntax Error");
 }
:};

terminal	IDENTIFIER, I_CONSTANT, F_CONSTANT, STRING_LITERAL, FUNC_NAME, SIZEOF;
terminal	PTR_OP, INC_OP, DEC_OP, LEFT_OP, RIGHT_OP, LE_OP, GE_OP, EQ_OP, NE_OP;
terminal	AND_OP, OR_OP, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN;
terminal	SUB_ASSIGN, LEFT_ASSIGN, RIGHT_ASSIGN, AND_ASSIGN;
terminal	XOR_ASSIGN, OR_ASSIGN;
terminal	TYPEDEF_NAME, ENUMERATION_CONSTANT;

terminal	TYPEDEF, EXTERN, STATIC, AUTO, REGISTER, INLINE;
terminal	CONST, RESTRICT, VOLATILE;
terminal	BOOL, CHAR, SHORT, INT, LONG, SIGNED, UNSIGNED, FLOAT, DOUBLE, VOID;
terminal	COMPLEX, IMAGINARY;
terminal	STRUCT, UNION, ENUM, ELLIPSIS;

terminal LT, GT, AND, PIPE, DOT, DDOT, TIL, CARET, EQUALS, INTER, LPAREN, RPAREN, COMMA, PLUS, MINUS, LBRA, RBRA, LKEY, RKEY, SEMICOLON, STAR, BAR, PERC, EXCLA;

terminal	CASE, DEFAULT, IF, ELSE, SWITCH, WHILE, DO, FOR, GOTO, CONTINUE, BREAK, RETURN;

terminal	ALIGNAS, ALIGNOF, ATOMIC, GENERIC, NORETURN, STATIC_ASSERT, THREAD_LOCAL;

non terminal primary_expression, constant,enumeration_constant, string, generic_selection, generic_assoc_list, generic_association;
non terminal postfix_expression, argument_expression_list, unary_expression, unary_operator, cast_expression, multiplicative_expression, additive_expression, shift_expression;
non terminal relational_expression, equality_expression, and_expression, exclusive_or_expression, inclusive_or_expression, logical_and_expression, logical_or_expression, conditional_expression;
non terminal assignment_expression, assignment_operator, expression, constant_expression, declaration, declaration_specifiers, init_declarator_list, init_declarator, storage_class_specifier, type_specifier;
non terminal struct_or_union_specifier, struct_or_union, struct_declaration_list, struct_declaration, specifier_qualifier_list, struct_declarator_list, struct_declarator;
non terminal enum_specifier, enumerator_list, enumerator, atomic_type_specifier, type_qualifier, function_specifier, alignment_specifier, declarator, direct_declarator;
non terminal pointer, type_qualifier_list, parameter_type_list, parameter_list, parameter_declaration, identifier_list, type_name, abstract_declarator, direct_abstract_declarator;
non terminal initializer, initializer_list, designation, designator_list, designator, static_assert_declaration, statement, labeled_statement, compound_statement, block_item_list, block_item;
non terminal expression_statement, selection_statement, iteration_statement, jump_statement, translation_unit, external_declaration, function_definition, declaration_list;

precedence nonassoc ELSE;

start with translation_unit;

primary_expression ::= IDENTIFIER:i {:Logger.print("Line 66"); RESULT = i;:}
  | constant:c {: RESULT=c; :}
  | string:s {: Expression ep = new Expression(new Type("char"),(String) s); RESULT=ep; :}
  | LPAREN expression:ep RPAREN {:Logger.print("Line 69"); RESULT = ep;:}
  | generic_selection
  ;

constant ::= I_CONSTANT:c {: RESULT=new Expression(new Type("int"), c.toString()); :}
  | F_CONSTANT:c {: RESULT=new Expression(new Type("float"), c.toString()); :}
  | ENUMERATION_CONSTANT
  ;

enumeration_constant ::= IDENTIFIER:i {:Logger.print("Line 78"); RESULT = i;:}
;

string ::= STRING_LITERAL:s {: Expression ep = new Expression(new Type("char"),(String) s);
RESULT = ep; :}
	         | FUNC_NAME
	          ;

generic_selection
	::= GENERIC LPAREN assignment_expression COMMA generic_assoc_list RPAREN
  ;

generic_assoc_list
	::= generic_association
	| generic_assoc_list COMMA generic_association
	;

generic_association
	::= type_name DDOT assignment_expression
	| DEFAULT DDOT assignment_expression
	;

postfix_expression
	::= primary_expression:ep {: Logger.print("Line 100"); RESULT=ep; :}
	| postfix_expression LBRA expression RBRA {:Logger.print("Line 101"); :}
	| postfix_expression:id LPAREN RPAREN {:Logger.print("Line 102"); :}
	| postfix_expression:id LPAREN argument_expression_list RPAREN {:Logger.print("Line 103"); :}
	| postfix_expression DOT IDENTIFIER {:Logger.print("Line 104"); :}
	| postfix_expression PTR_OP IDENTIFIER {:Logger.print("Line 105"); :}
	| postfix_expression INC_OP {:Logger.print("Line 106"); :}
	| postfix_expression DEC_OP {:Logger.print("Line 107"); :}
	| LPAREN type_name RPAREN LKEY initializer_list RKEY {:Logger.print("Line 108"); :}
	| LPAREN type_name RPAREN LKEY initializer_list COMMA RKEY {:Logger.print("Line 109"); :}
	;

argument_expression_list
	::= assignment_expression
	| argument_expression_list COMMA assignment_expression
	;

unary_expression
	::= postfix_expression:ep {: if (ep instanceof String) {Variable v = SemanticImpl.getInstance().findVariableByIdentifier((String) ep);
                                                if (v.getValue() != null) {
                                                  RESULT=v.getValue();
                                                } else {
                                                  RESULT=new Expression((Type) v.getType());
                                                }} else {
                                                  RESULT=ep;
                                                } :}
	| INC_OP unary_expression
	| DEC_OP unary_expression
	| unary_operator cast_expression
	| SIZEOF unary_expression
	| SIZEOF LPAREN type_name RPAREN
	| ALIGNOF LPAREN type_name RPAREN
	;

unary_operator
	::= AND
	| STAR
	| PLUS
	| MINUS
	| TIL
	| EXCLA
	;

cast_expression
	::= unary_expression:ep {:	if (ep instanceof String) {
                          						Variable v = SemanticImpl.getInstance().findVariableByIdentifier((String) ep);
                          						if (v.getValue() != null) {
                            						RESULT = v.getValue();
                          						} else {
                            						RESULT = new Expression((Type) v.getType());
                    							           }
  											  					} else {
                              					RESULT = ep;
                            					}	:}
	| LPAREN type_name RPAREN cast_expression
	;

multiplicative_expression
	::= cast_expression:ep  {: Logger.print("Line 141"); RESULT=ep; :}
	| multiplicative_expression:le STAR cast_expression:re {: RESULT = SemanticImpl.getInstance().getExpression((Expression) le,  "*", (Expression) re); :}
	| multiplicative_expression:le BAR cast_expression:re {: RESULT = SemanticImpl.getInstance().getExpression((Expression) le,  "/", (Expression) re); :}
	| multiplicative_expression:le PERC cast_expression:re {: RESULT = SemanticImpl.getInstance().getExpression((Expression) le,  "%", (Expression) re); :}
	;

additive_expression
	::= multiplicative_expression:ep {: RESULT=ep; :}
	| additive_expression:le PLUS multiplicative_expression:re {: RESULT = SemanticImpl.getInstance().getExpression((Expression) le,  "+", (Expression) re); :}
	| additive_expression:le MINUS multiplicative_expression:re {: RESULT = SemanticImpl.getInstance().getExpression((Expression) le,  "-", (Expression) re); :}
	;

shift_expression
	::= additive_expression:ep {: RESULT=ep; :}
	| shift_expression LEFT_OP additive_expression
	| shift_expression RIGHT_OP additive_expression
	;

relational_expression
	::= shift_expression:ep  {: Logger.print("Line 160"); RESULT=ep; :}
	| relational_expression LT shift_expression {: Logger.print("Line 161"); :}
	| relational_expression GT shift_expression {: Logger.print("Line 162"); :}
	| relational_expression LE_OP shift_expression {: Logger.print("Line 163"); :}
	| relational_expression GE_OP shift_expression {: Logger.print("Line 164"); :}
	;

equality_expression
	::= relational_expression:ep  {: Logger.print("Line 164"); RESULT=ep; :}
	| equality_expression EQ_OP relational_expression {: Logger.print("Line 169"); :}
	| equality_expression NE_OP relational_expression {: Logger.print("Line 170"); :}
	;

and_expression
	::= equality_expression
	| and_expression AND equality_expression
	;

exclusive_or_expression
	::= and_expression
	| exclusive_or_expression CARET and_expression
	;

inclusive_or_expression
	::= exclusive_or_expression
	| inclusive_or_expression PIPE exclusive_or_expression
	;

logical_and_expression
	::= inclusive_or_expression
	| logical_and_expression AND_OP inclusive_or_expression
	;

logical_or_expression
	::= logical_and_expression
	| logical_or_expression OR_OP logical_and_expression
	;

conditional_expression
	::= logical_or_expression:ep {: Logger.print("Line 200"); RESULT=ep; :}
	| logical_or_expression INTER expression DDOT conditional_expression
	;

assignment_expression
	::= conditional_expression:ep {: Logger.print("Line 205"); RESULT=ep; :}
	| unary_expression:id assignment_operator:op assignment_expression:e {: Logger.print("Line 205");
                                                        Variable var;
                                                        if (id instanceof String) {
                                                                                    SemanticImpl.getInstance().checkVariableAttribution((String) id, (Expression) e);
                                                          var = SemanticImpl.getInstance().findVariableByIdentifier((String) id);
                                                          var.setValue((Expression) e);
                                                          RESULT = e;
                                                        } else {
                                                          RESULT = e;
                                                        } :}
	;

assignment_operator
	::= EQUALS
	| MUL_ASSIGN {:	RESULT = "*";	:}
	| DIV_ASSIGN {:	RESULT = "/";	:}
	| MOD_ASSIGN {:	RESULT = "%";	:}
	| ADD_ASSIGN {:	RESULT = "+";	:}
	| SUB_ASSIGN {:	RESULT = "-";	:}
	| LEFT_ASSIGN
	| RIGHT_ASSIGN
	| AND_ASSIGN
	| XOR_ASSIGN
	| OR_ASSIGN
	;

expression
	::= assignment_expression:e {: Logger.print("Line 223"); RESULT =  ListCreator.newList(e); :}
	| expression:e COMMA assignment_expression:el {: Logger.print("Line 224"); ((ArrayList<Expression>) el).add((Expression)e); RESULT = e; :}
	;

constant_expression
	::= conditional_expression {: Logger.print("Line 228"); :}	/* with constraints */
	;

declaration
	::= declaration_specifiers:ds SEMICOLON {: Logger.print("Line 232"); SemanticImpl.getInstance().addVariablesFromTempList((Type) ds); :}
	| declaration_specifiers:ds init_declarator_list:idl /*{:
	  if (ds.toString().indexOf(">typedef<")>0) {
	      for (XMLElement e:
          ((XMLElement)idl).selectById("identifier"))
		        Parser.addType(((Terminal)e).value().toString());
	  }
	  :}*/ SEMICOLON {: Logger.print("Line 239"); SemanticImpl.getInstance().addVariablesFromTempList((Type) ds); :}
	| static_assert_declaration {: Logger.print("Line 240"); :}
	;

declaration_specifiers
	::= storage_class_specifier declaration_specifiers:t	{:	RESULT = t; :}
	| storage_class_specifier
	| type_specifier declaration_specifiers
	| type_specifier:t {: Logger.print("Line 239"); RESULT = t; :}
	| type_qualifier declaration_specifiers
	| type_qualifier
	| function_specifier declaration_specifiers
	| function_specifier
	| alignment_specifier declaration_specifiers
	| alignment_specifier
	;

init_declarator_list
	::= init_declarator:v {: Logger.print("Line 258"); RESULT = v; :}
	| init_declarator_list COMMA init_declarator
	;

init_declarator
	::= declarator:id EQUALS initializer:ep {: Variable v = new Variable((String) id, new Type("null"), (Expression) ep); SemanticImpl.getInstance().addVariableToTempList(v); RESULT=v; :}
	| declarator:id {: Variable v = new Variable((String) id, new Type("null"));SemanticImpl.getInstance().addVariableToTempList(v);RESULT=v; :}
	;

storage_class_specifier
	::= TYPEDEF
	| EXTERN
	| STATIC
	| THREAD_LOCAL
	| AUTO
	| REGISTER
	;

type_specifier
	::= VOID {:RESULT = new Type("void"); Logger.print("VOID at line 276");:}
	| CHAR {:RESULT = new Type("char"); Logger.print("CHAR at line 277");:}
	| SHORT {:RESULT = new Type("short"); Logger.print("SHORT at line 278");:}
	| INT {:RESULT = new Type("int"); Logger.print("INT at line 279");:}
	| LONG {:RESULT = new Type("long"); Logger.print("LONG at line 280");:}
	| FLOAT {:RESULT = new Type("float"); Logger.print("FLOAT at line 281");:}
	| DOUBLE {:RESULT = new Type("double"); Logger.print("DOUBLE at line 282");:}
	| SIGNED {:RESULT = new Type("signed"); Logger.print("SIGNED at line 283");:}
	| UNSIGNED {:RESULT = new Type("unsigned"); Logger.print("UNSIGNED at line 284");:}
	| BOOL {:RESULT = new Type("bool"); Logger.print("BOOL at line 285");:}
	| COMPLEX
	| IMAGINARY  	/* non-mandated extension */
	| atomic_type_specifier:ats {:Type t = new Type((String) ats); RESULT = t; Logger.print("line 288");:}
	| struct_or_union_specifier:sous {:Type t = new Type((String) sous); RESULT = t;; Logger.print("line 289");:}
	| enum_specifier:es {:Type t = new Type((String) es); RESULT = t; Logger.print("line 290");:}
	| TYPEDEF_NAME
	;

struct_or_union_specifier
	::= struct_or_union LKEY struct_declaration_list RKEY
	| struct_or_union IDENTIFIER LKEY struct_declaration_list RKEY
	| struct_or_union IDENTIFIER
	;

struct_or_union
	::= STRUCT
	| UNION
	;

struct_declaration_list
	::= struct_declaration
	| struct_declaration_list struct_declaration
	;

struct_declaration
	::= specifier_qualifier_list SEMICOLON	/* for anonymous struct/union */
	| specifier_qualifier_list struct_declarator_list SEMICOLON
	| static_assert_declaration
	;

specifier_qualifier_list
	::= type_specifier specifier_qualifier_list
	| type_specifier
	| type_qualifier specifier_qualifier_list
	| type_qualifier
	;

struct_declarator_list
	::= struct_declarator
	| struct_declarator_list COMMA struct_declarator
	;

struct_declarator
	::= DDOT constant_expression
	| declarator DDOT constant_expression
	| declarator
	;

enum_specifier
	::= ENUM LKEY enumerator_list RKEY
	| ENUM LKEY enumerator_list COMMA RKEY
	| ENUM IDENTIFIER LKEY enumerator_list RKEY
	| ENUM IDENTIFIER LKEY enumerator_list COMMA RKEY
	| ENUM IDENTIFIER
	;

enumerator_list
	::= enumerator
	| enumerator_list COMMA enumerator
	;

enumerator	/* identifiers must be flagged as ENUMERATION_CONSTANT */
	::= enumeration_constant EQUALS constant_expression
	| enumeration_constant
	;

/*atomic_type_specifier
	::= ATOMIC LPAREN type_name RPAREN
	;*/

type_qualifier
	::= CONST
	| RESTRICT
	| VOLATILE
	| ATOMIC
	;

function_specifier
	::= INLINE
	| NORETURN
	;

alignment_specifier
	::= ALIGNAS LPAREN type_name RPAREN
	| ALIGNAS LPAREN constant_expression RPAREN
	;

declarator
	::= pointer direct_declarator {: Logger.print("Line 375"); :}
	| direct_declarator:v {: Logger.print("Line 376"); RESULT =  v; :}
	;

direct_declarator
	::= IDENTIFIER:id {: Logger.print("Line 380"); RESULT = id; :}
	| LPAREN declarator RPAREN
	| direct_declarator LBRA RBRA
	| direct_declarator LBRA STAR RBRA
	| direct_declarator LBRA STATIC type_qualifier_list assignment_expression RBRA
	| direct_declarator LBRA STATIC assignment_expression RBRA
	| direct_declarator LBRA type_qualifier_list STAR RBRA
	| direct_declarator LBRA type_qualifier_list STATIC assignment_expression RBRA
	| direct_declarator LBRA type_qualifier_list assignment_expression RBRA
	| direct_declarator LBRA type_qualifier_list RBRA
	| direct_declarator LBRA assignment_expression RBRA
	| direct_declarator:id LPAREN parameter_type_list:parameter_list RPAREN
	| direct_declarator LPAREN RPAREN
	| direct_declarator LPAREN identifier_list RPAREN
	;

pointer
	::= STAR type_qualifier_list pointer
	| STAR type_qualifier_list
	| STAR pointer
	| STAR
	;

type_qualifier_list
	::= type_qualifier
	| type_qualifier_list type_qualifier
	;


parameter_type_list
	::= parameter_list COMMA ELLIPSIS
	| parameter_list:pl {: Logger.print("Line 418"); RESULT=pl; :}
	;

parameter_list
	::= parameter_declaration:p {:Logger.print("Line 422"); RESULT =  ListCreator.newList(p);:}
	| parameter_list:pl COMMA parameter_declaration:p {: ((ArrayList<Parameter>) pl).add(0, (Parameter) p); RESULT = pl; :}
	;

parameter_declaration
	::= declaration_specifiers:t declarator:id {: Variable v = new Variable((String) id, (Type) t);RESULT = v; :}
	| declaration_specifiers abstract_declarator
	| declaration_specifiers
	;

identifier_list
	::= IDENTIFIER
	| identifier_list COMMA IDENTIFIER
	;

type_name
	::= specifier_qualifier_list abstract_declarator
	| specifier_qualifier_list
	;

abstract_declarator
	::= pointer direct_abstract_declarator
	| pointer
	| direct_abstract_declarator
	;

direct_abstract_declarator
	::= LPAREN abstract_declarator RPAREN
	| LBRA RBRA
	| LBRA STAR RBRA
	| LBRA STATIC type_qualifier_list assignment_expression RBRA
	| LBRA STATIC assignment_expression RBRA
	| LBRA type_qualifier_list STATIC assignment_expression RBRA
	| LBRA type_qualifier_list assignment_expression RBRA
	| LBRA type_qualifier_list RBRA
	| LBRA assignment_expression RBRA
	| direct_abstract_declarator LBRA RBRA
	| direct_abstract_declarator LBRA STAR RBRA
	| direct_abstract_declarator LBRA STATIC type_qualifier_list assignment_expression RBRA
	| direct_abstract_declarator LBRA STATIC assignment_expression RBRA
	| direct_abstract_declarator LBRA type_qualifier_list assignment_expression RBRA
	| direct_abstract_declarator LBRA type_qualifier_list STATIC assignment_expression RBRA
	| direct_abstract_declarator LBRA type_qualifier_list RBRA
	| direct_abstract_declarator LBRA assignment_expression RBRA
	| LPAREN RPAREN
	| LPAREN parameter_type_list RPAREN
	| direct_abstract_declarator LPAREN RPAREN
	| direct_abstract_declarator LPAREN parameter_type_list RPAREN
	;

initializer
	::= LKEY initializer_list RKEY
	| LKEY initializer_list COMMA RKEY
	| assignment_expression:ep {: Logger.print("Line 468"); RESULT=ep; :}
	;

initializer_list
	::= designation initializer
	| initializer
	| initializer_list COMMA designation initializer
	| initializer_list COMMA initializer
	;

designation
	::= designator_list EQUALS
	;

designator_list
	::= designator
	| designator_list designator
	;

designator
	::= LBRA constant_expression RBRA
	| DOT IDENTIFIER
	;

static_assert_declaration
	::= STATIC_ASSERT LPAREN constant_expression COMMA STRING_LITERAL RPAREN SEMICOLON
	;

statement
	::= labeled_statement
	| /*{: Parser.newScope(); :}*/ compound_statement //{: Parser.deleteScope(); :}
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement:st {: RESULT=st; :}
	;

labeled_statement
	::= IDENTIFIER DDOT statement
	| CASE constant_expression DDOT statement
	| DEFAULT DDOT statement
	;

compound_statement
	::= LKEY RKEY
	| LKEY  block_item_list:st RKEY {: Logger.print("Line 513"); RESULT =  st; :}
	;

block_item_list
	::= block_item:st {:  Logger.print("Line 517"); RESULT=st; :}
	| block_item_list block_item:st {:  Logger.print("Line 518"); RESULT=st; :}
	;

block_item
	::= declaration
	| statement:st {: Logger.print("Line 523"); RESULT=st; :}
	;

expression_statement
	::= SEMICOLON
	| expression SEMICOLON
	;

selection_statement
	::= IF LPAREN expression RPAREN statement ELSE statement
	| IF LPAREN expression RPAREN statement
	| SWITCH LPAREN expression RPAREN statement
	;

iteration_statement
	::= WHILE LPAREN expression RPAREN statement
	| DO statement WHILE LPAREN expression RPAREN SEMICOLON
	| FOR LPAREN expression_statement expression_statement RPAREN statement {:Logger.print("Line 539");:}
	| FOR LPAREN expression_statement expression_statement expression RPAREN statement {:Logger.print("Line 540");:}
	| FOR LPAREN declaration expression_statement RPAREN statement {:Logger.print("Line 541");:}
	| FOR LPAREN declaration expression_statement expression RPAREN statement {:Logger.print("Line 542");:}
	;

jump_statement
	::= GOTO IDENTIFIER SEMICOLON
	| CONTINUE SEMICOLON
	| BREAK SEMICOLON
	| RETURN SEMICOLON
	| RETURN expression SEMICOLON
	;

translation_unit
	::= external_declaration
	| translation_unit external_declaration
	;

external_declaration
	::= function_definition
	| declaration
	;

function_definition ::=declaration_specifiers declarator declaration_list
    compound_statement		                 // {: Parser.deleteScope(); :}
  	| declaration_specifiers declarator 	 // {: Parser.newScope(); :}
  	  compound_statement 	                 // {: Parser.deleteScope(); :}
  	| declarator declaration_list 	       // {: Parser.newScope(); :}
  	  compound_statement	                 // {: Parser.deleteScope(); :}
  	| declarator                           // {: Parser.newScope(); :}
  	  compound_statement 	                 // {: Parser.deleteScope(); :}
  	;

declaration_list
	::= declaration
	| declaration_list declaration
	;
